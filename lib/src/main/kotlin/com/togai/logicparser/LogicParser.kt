/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.togai.logicparser

import io.github.jamsesso.jsonlogic.JsonLogic
import io.github.jamsesso.jsonlogic.JsonLogicException
import io.github.jamsesso.jsonlogic.ast.JsonLogicArray
import io.github.jamsesso.jsonlogic.ast.JsonLogicNode
import io.github.jamsesso.jsonlogic.ast.JsonLogicOperation
import io.github.jamsesso.jsonlogic.ast.JsonLogicParser
import io.github.jamsesso.jsonlogic.ast.JsonLogicString
import io.github.jamsesso.jsonlogic.ast.JsonLogicVariable
import io.github.jamsesso.jsonlogic.evaluator.expressions.AllExpression
import io.github.jamsesso.jsonlogic.evaluator.expressions.ArrayHasExpression
import io.github.jamsesso.jsonlogic.evaluator.expressions.ConcatenateExpression
import io.github.jamsesso.jsonlogic.evaluator.expressions.EqualityExpression
import io.github.jamsesso.jsonlogic.evaluator.expressions.FilterExpression
import io.github.jamsesso.jsonlogic.evaluator.expressions.IfExpression
import io.github.jamsesso.jsonlogic.evaluator.expressions.InExpression
import io.github.jamsesso.jsonlogic.evaluator.expressions.InequalityExpression
import io.github.jamsesso.jsonlogic.evaluator.expressions.LogExpression
import io.github.jamsesso.jsonlogic.evaluator.expressions.LogicExpression
import io.github.jamsesso.jsonlogic.evaluator.expressions.MapExpression
import io.github.jamsesso.jsonlogic.evaluator.expressions.MathExpression
import io.github.jamsesso.jsonlogic.evaluator.expressions.MergeExpression
import io.github.jamsesso.jsonlogic.evaluator.expressions.MissingExpression
import io.github.jamsesso.jsonlogic.evaluator.expressions.NotExpression
import io.github.jamsesso.jsonlogic.evaluator.expressions.NumericComparisonExpression
import io.github.jamsesso.jsonlogic.evaluator.expressions.ReduceExpression
import io.github.jamsesso.jsonlogic.evaluator.expressions.StrictEqualityExpression
import io.github.jamsesso.jsonlogic.evaluator.expressions.StrictInequalityExpression
import io.github.jamsesso.jsonlogic.evaluator.expressions.SubstringExpression
import java.util.Queue
import java.util.LinkedList

class LogicParser {
    companion object {
        const val DIMENSIONS = "dimensions"
        const val ATTRIBUTES = "attributes"
    }

    private val jsonLogic = JsonLogic()
    private val expressionNames: HashSet<String> = HashSet()

    init {
        // TODO: Create a PR in json logic repo to expose all supported operations
        expressionNames.addAll(
            hashSetOf(
                MathExpression.ADD.key(),
                MathExpression.SUBTRACT.key(),
                MathExpression.MULTIPLY.key(),
                MathExpression.DIVIDE.key(),
                MathExpression.MODULO.key(),
                MathExpression.MIN.key(),
                MathExpression.MAX.key(),
                NumericComparisonExpression.GT.key(),
                NumericComparisonExpression.GTE.key(),
                NumericComparisonExpression.LT.key(),
                NumericComparisonExpression.LTE.key(),
                IfExpression.IF.key(),
                IfExpression.TERNARY.key(),
                EqualityExpression.INSTANCE.key(),
                InequalityExpression.INSTANCE.key(),
                StrictEqualityExpression.INSTANCE.key(),
                StrictInequalityExpression.INSTANCE.key(),
                NotExpression.SINGLE.key(),
                NotExpression.DOUBLE.key(),
                LogicExpression.AND.key(),
                LogicExpression.OR.key(),
                LogExpression.STDOUT.key(),
                MapExpression.INSTANCE.key(),
                FilterExpression.INSTANCE.key(),
                ReduceExpression.INSTANCE.key(),
                AllExpression.INSTANCE.key(),
                ArrayHasExpression.SOME.key(),
                ArrayHasExpression.NONE.key(),
                MergeExpression.INSTANCE.key(),
                InExpression.INSTANCE.key(),
                ConcatenateExpression.INSTANCE.key(),
                SubstringExpression.INSTANCE.key(),
                MissingExpression.ALL.key(),
                MissingExpression.SOME.key()
            )
        )
    }

    /**
     * Method to add custom operations
     * @param name Name of the function
     * @param function Function to execute
     */
    fun addOperation(name: String, function: (Array<Any>) -> Any) {
        expressionNames.add(name)
        jsonLogic.addOperation(name, function)
    }

    /**
     * Method to validate whether the rule is valid or not.
     * @param rule Rule in json format to validate
     * @param attributes List of Attribute instance
     * @param dimensions List of Dimension instance
     * @return ValidationResponse
     **/
    fun validateExpression(rule: String, attributes: List<Attribute>, dimensions: List<Dimension>): ValidationResponse {
        val variables = HashSet<String>()

        attributes.forEach {
            variables.add("$ATTRIBUTES.${it.name}")
        }
        dimensions.forEach {
            variables.add("$DIMENSIONS.${it.name}")
        }

        try {
            val node = JsonLogicParser.parse(rule)
            traverseNode(node, variables)
        } catch (e: JsonLogicException) {
            return ValidationResponse(false, e.message)
        }
        return ValidationResponse(true)
    }

    /**
     * Method to evaluate the rule using the given data.
     * @param rule Rule in json format to evaluate
     * @param attributeValues List of AttributeValue instance
     * @param dimensionValues List of DimensionValue instance
     * @return The response of evaluation
     **/
    fun evaluateExpression(
        rule: String,
        attributeValues: List<AttributeValue>,
        dimensionValues: List<DimensionValue>
    ): Any? {
        val data: HashMap<String, HashMap<String, String>> =
            hashMapOf(ATTRIBUTES to hashMapOf(), DIMENSIONS to hashMapOf())
        for (attributeValue in attributeValues) {
            data[ATTRIBUTES]!![attributeValue.name] = attributeValue.value
        }
        for (dimensionValue in dimensionValues) {
            data[DIMENSIONS]!![dimensionValue.name] = dimensionValue.value
        }
        return jsonLogic.apply(rule, data)
    }

    private fun traverseNode(rootNode: JsonLogicNode, variables: HashSet<String>) {
        val nodes: Queue<JsonLogicNode> = LinkedList()
        nodes.add(rootNode)
        while (nodes.isNotEmpty()) {
            when (val node = nodes.poll()) {
                is JsonLogicVariable -> {
                    if (node.key !is JsonLogicString) {
                        throw JsonLogicException("Variable name must be a string")
                    }
                    if (!variables.contains((node.key as JsonLogicString).value)) {
                        throw JsonLogicException("Unknown variable: ${node.key}")
                    }
                }
                is JsonLogicArray -> {
                    node.forEach {
                        nodes.add(it)
                    }
                }
                is JsonLogicOperation -> {
                    if (!expressionNames.contains(node.operator)) {
                        throw JsonLogicException("Unknown operator/operation: ${node.operator}")
                    }
                    node.arguments.forEach {
                        nodes.add(it)
                    }
                }
            }
        }
    }
}

